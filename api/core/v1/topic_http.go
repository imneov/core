// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http 0.1.0

package v1

import (
	context "context"
	"encoding/base64"

	"io/ioutil"
	http "net/http"
	reflect "reflect"

	go_restful "github.com/emicklei/go-restful"
	"github.com/tidwall/gjson"
	errors "github.com/tkeel-io/kit/errors"
	emptypb "google.golang.org/protobuf/types/known/emptypb"

	transportHTTP "github.com/tkeel-io/kit/transport/http"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the tkeel package it is being compiled against.
// import package.context.http.reflect.go_restful.json.errors.emptypb.

type TopicHTTPServer interface {
	TopicEventHandler(context.Context, *TopicEventRequest) (*TopicEventResponse, error)
}

type TopicHTTPHandler struct {
	srv TopicHTTPServer
}

func newTopicHTTPHandler(s TopicHTTPServer) *TopicHTTPHandler {
	return &TopicHTTPHandler{srv: s}
}

func (h *TopicHTTPHandler) TopicEventHandler(req *go_restful.Request, resp *go_restful.Response) {
	in := TopicEventRequest{}
	defer req.Request.Body.Close()
	bytes, err := ioutil.ReadAll(req.Request.Body)
	if nil != err {
		tErr := errors.FromError(err)
		httpCode := errors.GRPCToHTTPStatusCode(tErr.GRPCStatus().Code())
		resp.WriteErrorString(httpCode, tErr.Message)
		return
	}

	res := gjson.GetBytes(bytes, "data")
	in.RawData = []byte(res.String())

	res = gjson.GetBytes(bytes, "data_base64")
	if res.Type != gjson.Null {
		// decode base64.
		base64.StdEncoding.Decode(in.RawData, []byte(res.String()))
	}

	meta := Metadata{}
	if err = json.Unmarshal(bytes, &meta); nil != err {
		tErr := errors.FromError(err)
		httpCode := errors.GRPCToHTTPStatusCode(tErr.GRPCStatus().Code())
		resp.WriteErrorString(httpCode, tErr.Message)
		return
	}

	in.Meta = &meta
	ctx := transportHTTP.ContextWithHeader(req.Request.Context(), req.Request.Header)

	out, err := h.srv.TopicEventHandler(ctx, &in)
	if err != nil {
		tErr := errors.FromError(err)
		httpCode := errors.GRPCToHTTPStatusCode(tErr.GRPCStatus().Code())
		resp.WriteErrorString(httpCode, tErr.Message)
		return
	}
	if reflect.ValueOf(out).Elem().Type().AssignableTo(reflect.TypeOf(emptypb.Empty{})) {
		resp.WriteHeader(http.StatusNoContent)
		return
	}
	result, err := json.Marshal(out)
	if err != nil {
		resp.WriteErrorString(http.StatusInternalServerError, err.Error())
		return
	}
	_, err = resp.Write(result)
	if err != nil {
		resp.WriteErrorString(http.StatusInternalServerError, err.Error())
		return
	}
}

func isBase64() bool {
	return false
}

func RegisterTopicHTTPServer(container *go_restful.Container, srv TopicHTTPServer) {
	var ws *go_restful.WebService
	for _, v := range container.RegisteredWebServices() {
		if v.RootPath() == "/v1" {
			ws = v
			break
		}
	}
	if ws == nil {
		ws = new(go_restful.WebService)
		ws.ApiVersion("/v1")
		ws.Path("/v1").Produces(go_restful.MIME_JSON)
		container.Add(ws)
	}

	handler := newTopicHTTPHandler(srv)
	ws.Route(ws.POST("/topic").
		To(handler.TopicEventHandler))
}
